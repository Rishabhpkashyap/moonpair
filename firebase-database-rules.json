{
  "rules": {
    // Users data - each user can only access their own data
    "users": {
      "$userId": {
        ".read": "auth != null && auth.uid == $userId",
        ".write": "auth != null && auth.uid == $userId",
        
        // Profile data
        "profile": {
          ".validate": "newData.hasChildren(['name', 'email'])"
        },
        
        // Cycle data - only for authenticated user
        "cycle": {
          ".validate": "newData.hasChildren() || newData.val() == null",
          "cycleLength": {
            ".validate": "newData.isNumber() && newData.val() >= 21 && newData.val() <= 35"
          },
          "periodLength": {
            ".validate": "newData.isNumber() && newData.val() >= 3 && newData.val() <= 8"
          },
          "history": {
            "$historyId": {
              "startDate": {
                ".validate": "newData.isString() && newData.val().matches(/^\\d{4}-\\d{2}-\\d{2}$/)"
              },
              "endDate": {
                ".validate": "newData.isString() && newData.val().matches(/^\\d{4}-\\d{2}-\\d{2}$/) || newData.val() == null"
              }
            }
          }
        },
        
        // Partner connection data
        "partner": {
          ".validate": "newData.hasChildren(['partnerId', 'partnerEmail', 'partnerName']) || newData.val() == null",
          "partnerId": {
            ".validate": "newData.isString() && newData.val().length > 0"
          },
          "partnerEmail": {
            ".validate": "newData.isString() && newData.val().matches(/^[^@]+@[^@]+\\.[^@]+$/)"
          },
          "partnerName": {
            ".validate": "newData.isString() && newData.val().length > 0"
          }
        }
      }
    },
    
    // Chat data - accessible by both users in the conversation
    "chats": {
      "$chatId": {
        // Chat ID format: userId1_userId2 (sorted alphabetically)
        ".read": "auth != null && ($chatId.contains(auth.uid + '_') || $chatId.contains('_' + auth.uid) || $chatId == auth.uid + '_' + auth.uid)",
        ".write": "auth != null && ($chatId.contains(auth.uid + '_') || $chatId.contains('_' + auth.uid) || $chatId == auth.uid + '_' + auth.uid)",
        
        "messages": {
          "$messageId": {
            ".validate": "newData.hasChildren(['text', 'senderId', 'timestamp'])",
            "text": {
              ".validate": "newData.isString() && newData.val().length > 0 && newData.val().length <= 1000"
            },
            "senderId": {
              ".validate": "newData.isString() && newData.val() == auth.uid"
            },
            "timestamp": {
              ".validate": "newData.isNumber() && newData.val() <= now"
            },
            "status": {
              ".validate": "newData.isString() && (newData.val() == 'sent' || newData.val() == 'delivered' || newData.val() == 'read')"
            }
          }
        },
        
        "metadata": {
          "$metaId": {
            ".validate": "newData.hasChildren(['lastMessage', 'lastMessageTime', 'lastMessageSender'])",
            "lastMessageSender": {
              ".validate": "newData.isString() && newData.val() == auth.uid"
            }
          }
        }
      }
    },
    
    // Invite codes for partner connection
    "inviteCodes": {
      "$code": {
        // Anyone can read invite codes to validate them
        ".read": "auth != null",
        // Only the creator can write/update invite codes
        ".write": "auth != null && (newData.child('createdBy').val() == auth.uid || data.child('createdBy').val() == auth.uid)",
        
        ".validate": "newData.hasChildren(['createdBy', 'createdByEmail', 'createdByName', 'createdAt', 'expiresAt', 'used'])",
        
        "createdBy": {
          ".validate": "newData.isString() && newData.val() == auth.uid"
        },
        "createdByEmail": {
          ".validate": "newData.isString() && newData.val().matches(/^[^@]+@[^@]+\\.[^@]+$/)"
        },
        "createdByName": {
          ".validate": "newData.isString() && newData.val().length > 0"
        },
        "createdAt": {
          ".validate": "newData.isNumber() && newData.val() <= now"
        },
        "expiresAt": {
          ".validate": "newData.isNumber() && newData.val() > now"
        },
        "used": {
          ".validate": "newData.isBoolean()"
        },
        "usedBy": {
          ".validate": "newData.isString() || newData.val() == null"
        },
        "usedAt": {
          ".validate": "newData.isNumber() || newData.val() == null"
        }
      }
    },
    
    // Deny access to any other paths
    "$other": {
      ".read": false,
      ".write": false
    }
  }
}